generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  Int                     @id @default(autoincrement())
  email               String?
  username            String?                 @unique
  password            String?
  AdminsOnAssignments AdminsOnAssignments[]
  externalAccounts    ExternalAccount[]
  assignments         StudentsOnAssignments[]
  Submission          Submission[]
  TutorsOnAssignments TutorsOnAssignments[]
  permissions         Permission[]            @relation("PermissionToUser")
}

model ExternalAccount {
  id         Int    @id @default(autoincrement())
  userId     Int
  provider   String
  providerId String
  user       User   @relation(fields: [userId], references: [id])

  @@unique([provider, userId])
  @@unique([provider, providerId])
  @@index([userId])
}

model Permission {
  id          Int         @id @default(autoincrement())
  name        String
  description String?
  users       User[]      @relation("PermissionToUser")
  userGroups  UserGroup[] @relation("PermissionToUserGroup")
}

model UserGroup {
  id          Int          @id @default(autoincrement())
  name        String
  description String?
  permissions Permission[] @relation("PermissionToUserGroup")
}

model Assignment {
  id          Int                     @id @default(autoincrement())
  title       String
  description String?
  publishDate DateTime?
  dueDate     DateTime?
  admins      AdminsOnAssignments[]
  problems    Problem[]
  students    StudentsOnAssignments[]
  Submission  Submission[]
  tutors      TutorsOnAssignments[]
}

model AdminsOnAssignments {
  assignmentId Int
  userId       Int
  assignment   Assignment @relation(fields: [assignmentId], references: [id])
  user         User       @relation(fields: [userId], references: [id])

  @@id([assignmentId, userId])
  @@index([userId])
}

model TutorsOnAssignments {
  assignmentId Int
  userId       Int
  assignment   Assignment @relation(fields: [assignmentId], references: [id])
  user         User       @relation(fields: [userId], references: [id])

  @@id([assignmentId, userId])
  @@index([userId])
}

model StudentsOnAssignments {
  assignmentId Int
  userId       Int
  assignment   Assignment @relation(fields: [assignmentId], references: [id])
  user         User       @relation(fields: [userId], references: [id])

  @@id([assignmentId, userId])
  @@index([userId])
}

// Business layer problem
model Problem {
  id           Int     @id @default(autoincrement())
  name         String
  description  String?
  assignmentid Int

  assignment       Assignment         @relation(fields: [assignmentid], references: [id])
  VersionOnProblem VersionOnProblem[]
}

// Different versions of the same problem
model ProblemVersion {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  hash      String
  file      Bytes

  testcase         Testcase[]
  VersionOnProblem VersionOnProblem[]
  Submission       Submission[]

  @@index([hash])
}

model VersionOnProblem {
  problemId        Int
  problemVersionId Int
  problem          Problem        @relation(fields: [problemId], references: [id])
  problemVersion   ProblemVersion @relation(fields: [problemVersionId], references: [id])

  @@id([problemId, problemVersionId])
  @@index([problemVersionId])
}

enum TestCaseType {
  sample
  secret
}

model Testcase {
  id     Int          @id @default(autoincrement())
  type   TestCaseType
  name   String
  input  String
  output String

  problemVersionId Int
  problemVersion   ProblemVersion @relation(fields: [problemVersionId], references: [id], onDelete: Cascade)
  JudgeTask        JudgeTask[]
}

model Submission {
  id       Int      @id @default(autoincrement())
  dateTime DateTime @default(now())
  code     String
  comment  String?

  assignmentId     Int?
  problemVersionId Int
  userId           Int
  languageId       String

  ProblemVersion ProblemVersion @relation(fields: [problemVersionId], references: [id], onDelete: Restrict, onUpdate: Restrict, map: "fk_problem_version_submission")
  Language       Language       @relation(fields: [languageId], references: [id])
  Judge          Judge[]

  Assignment Assignment? @relation(fields: [assignmentId], references: [id], onDelete: Restrict, onUpdate: Restrict, map: "fk_assignment_submission")
  User       User        @relation(fields: [userId], references: [id], onDelete: Restrict, onUpdate: Restrict, map: "fk_user_submission")

  @@index([assignmentId])
  @@index([problemVersionId])
  @@index([userId])
}

model Judge {
  id           Int         @id @default(autoincrement())
  submissionId Int
  score        Int?
  time         Int?
  memory       Int?
  Submission   Submission  @relation(fields: [submissionId], references: [id])
  JudgeTask    JudgeTask[]
}

model JudgeTask {
  id     Int     @id @default(autoincrement())
  status String?

  judgeId    Int
  testcaseId Int
  Testcase   Testcase @relation(fields: [testcaseId], references: [id])
  Judge      Judge    @relation(fields: [judgeId], references: [id])
}

model Language {
  id                     String   @id @default(uuid())
  externalId             String
  name                   String
  extensions             String[]
  requireEntryPoint      Boolean
  entryPointDescription  String?
  allowSubmit            Boolean
  allowJudge             Boolean
  timeFactor             Float
  compilerVersionCommand String?
  runnerVersionCommand   String?

  Submission   Submission[]
  executableId String       @unique
  Executable   Executable   @relation(fields: [executableId], references: [id])
}

model Executable {
  id          String           @id @map("execId")
  description String
  type        String
  files       ExecutableFile[]

  languageId String?
  Language   Language?
}

model ExecutableFile {
  id           String  @id @default(uuid())
  name         String
  content      Bytes
  isExecutable Boolean

  Executable       Executable? @relation(fields: [executableExecId], references: [id])
  executableExecId String?
}
