generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id                  Int                     @id @default(autoincrement())
  email               String?
  username            String?                 @unique
  password            String?
  AdminsOnAssignments AdminsOnAssignments[]
  externalAccounts    ExternalAccount[]
  assignments         StudentsOnAssignments[]
  Submission          Submission[]
  TutorsOnAssignments TutorsOnAssignments[]
  permissions         Permission[]            @relation("PermissionToUser")
}

model ExternalAccount {
  id         Int    @id @default(autoincrement())
  userId     Int
  provider   String
  providerId String
  user       User   @relation(fields: [userId], references: [id])

  @@unique([provider, userId])
  @@unique([provider, providerId])
  @@index([userId])
}

model Permission {
  id          Int         @id @default(autoincrement())
  name        String
  description String?
  users       User[]      @relation("PermissionToUser")
  userGroups  UserGroup[] @relation("PermissionToUserGroup")
}

model UserGroup {
  id          Int          @id @default(autoincrement())
  name        String
  description String?
  permissions Permission[] @relation("PermissionToUserGroup")
}

model Assignment {
  id          Int                     @id @default(autoincrement())
  title       String
  description String?
  publishDate DateTime?
  dueDate     DateTime?
  admins      AdminsOnAssignments[]
  problems    Problem[]
  students    StudentsOnAssignments[]
  tutors      TutorsOnAssignments[]
}

model AdminsOnAssignments {
  assignmentId Int
  userId       Int
  assignment   Assignment @relation(fields: [assignmentId], references: [id])
  user         User       @relation(fields: [userId], references: [id])

  @@id([assignmentId, userId])
  @@index([userId])
}

model TutorsOnAssignments {
  assignmentId Int
  userId       Int
  assignment   Assignment @relation(fields: [assignmentId], references: [id])
  user         User       @relation(fields: [userId], references: [id])

  @@id([assignmentId, userId])
  @@index([userId])
}

model StudentsOnAssignments {
  assignmentId Int
  userId       Int
  assignment   Assignment @relation(fields: [assignmentId], references: [id])
  user         User       @relation(fields: [userId], references: [id])

  @@id([assignmentId, userId])
  @@index([userId])
}

// Business layer problem
model Problem {
  id           Int @id @default(autoincrement())
  assignmentId Int

  assignment       Assignment     @relation(fields: [assignmentId], references: [id])
  submission       Submission[]
  problemVersion   ProblemVersion @relation(fields: [problemVersionId], references: [id])
  problemVersionId Int
}

// Different versions of the same problem
model ProblemVersion {
  id        Int      @id @default(autoincrement())
  createdAt DateTime @default(now())
  hash      String
  file      Bytes

  testcase   Testcase[]
  problem    Problem[]
  submission Submission[]

  @@index([hash])
}

enum TestCaseType {
  sample
  secret
}

model Testcase {
  id     Int          @id @default(autoincrement())
  type   TestCaseType
  name   String
  input  String
  output String

  problemVersionId Int
  problemVersion   ProblemVersion @relation(fields: [problemVersionId], references: [id], onDelete: Cascade)
  JudgeTask        JudgeTask[]
}

model Submission {
  id       Int      @id @default(autoincrement())
  dateTime DateTime @default(now())
  code     String
  comment  String?
  judge    Judge[]

  languageId       String
  userId           Int
  problemVersionId Int?
  problemId        Int?

  language       Language        @relation(fields: [languageId], references: [id])
  user           User            @relation(fields: [userId], references: [id], onDelete: Restrict, onUpdate: Restrict)
  // A submission is either for a problem or a problem version directly
  problemVersion ProblemVersion? @relation(fields: [problemVersionId], references: [id], onDelete: Restrict, onUpdate: Restrict)
  problem        Problem?        @relation(fields: [problemId], references: [id])

  @@index([problemVersionId])
  @@index([userId])
}

model Judge {
  id           Int         @id @default(autoincrement())
  submissionId Int
  score        Int?
  time         Int?
  memory       Int?
  submission   Submission  @relation(fields: [submissionId], references: [id])
  judgeTask    JudgeTask[]
}

model JudgeTask {
  id     Int     @id @default(autoincrement())
  judgeId    Int
  testcaseId Int
  testcase   Testcase @relation(fields: [testcaseId], references: [id])
  judge      Judge    @relation(fields: [judgeId], references: [id])

  compileSuccess  Boolean?
  compileOutput   String?
  compileMetadata String?

  runResult String?
  runTime   Float?
  runOutput String?
  runError  String?
  runSystem String?
  runMetadata  String?
  runDiff String?
}

model Language {
  id                     String   @id @default(uuid())
  externalId             String
  name                   String
  extensions             String[]
  requireEntryPoint      Boolean
  entryPointDescription  String?
  allowSubmit            Boolean
  allowJudge             Boolean
  timeFactor             Float
  compilerVersionCommand String?
  runnerVersionCommand   String?

  submission   Submission[]
  executableId String       @unique
  executable   Executable   @relation(fields: [executableId], references: [id])
}

model Executable {
  id          String           @id @map("execId")
  description String
  type        String
  files       ExecutableFile[]

  languageId String?
  language   Language?
}

model ExecutableFile {
  id           String  @id @default(uuid())
  name         String
  content      Bytes
  isExecutable Boolean

  executable       Executable? @relation(fields: [executableExecId], references: [id])
  executableExecId String?
}
